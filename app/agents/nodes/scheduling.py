from app.agents.state import AgentState
from app.ueba.middleware import secure_call
from datetime import datetime, timedelta

# ==========================================
# üíæ MOCK DATABASE (Global Memory)
# ==========================================
# Stores all confirmed bookings to prevent double-booking.
BOOKINGS_DB = []

# ==========================================
# üõ†Ô∏è SERVICE LOGIC (Unchanged)
# ==========================================
class SchedulerService:
    
    @staticmethod
    def get_all_bookings():
        """
        Helper method for the API to fetch data for the Frontend.
        """
        return BOOKINGS_DB

    @staticmethod
    def find_next_available_slot(target_date_str):
        """
        Loops through standard work hours (09:00 - 17:00) 
        to find a slot that isn't already in BOOKINGS_DB.
        """
        # Define working hours (09:00 to 17:00)
        possible_slots = [f"{h:02d}:00" for h in range(9, 18)]
        
        # Filter DB for bookings strictly on this specific date
        taken_times = {b['slot_time'] for b in BOOKINGS_DB if b['slot_date'] == target_date_str}
        
        # Find first slot NOT in taken_times
        for slot in possible_slots:
            if slot not in taken_times:
                return slot
        
        return None # No slots available today

    @staticmethod
    def book_slot(vehicle_id: str, priority: str):
        """
        Determines slot based on priority, CHECKS AVAILABILITY, and saves to Mock DB.
        """
        print(f"üìÖ [System] Calculating slot for {vehicle_id} (Priority: {priority})...")
        
        # 1. Determine Initial Target Date based on Priority
        now = datetime.now()
        
        # For DEMO purposes, let's try to book everything for TOMORROW
        target_date = now + timedelta(days=1)
        
        service_note = f"Repair ({priority})"
        formatted_date = target_date.strftime("%Y-%m-%d")

        # 2. SMART LOGIC: Find a Real Available Time (Collision Detection)
        available_time = SchedulerService.find_next_available_slot(formatted_date)
        
        # Fallback if fully booked: Push to next day and reset to 09:00
        if not available_time:
            print(f"‚ö†Ô∏è [System] Date {formatted_date} is full! Checking next day...")
            target_date = target_date + timedelta(days=1)
            formatted_date = target_date.strftime("%Y-%m-%d")
            available_time = "09:00" # Reset to morning for the new day

        full_slot_str = f"{formatted_date} {available_time}"

        # 3. Create Booking Record
        new_booking = {
            "booking_id": f"BK-{int(now.timestamp())}", 
            "vin": vehicle_id,
            "slot_date": formatted_date,
            "slot_time": available_time,
            "service_type": service_note,
            "priority": priority,
            "status": "CONFIRMED",
            "timestamp": now.isoformat()
        }
        
        # 4. Save to Mock DB
        BOOKINGS_DB.append(new_booking)
        print(f"üíæ [DB] Booking saved: {new_booking['booking_id']} | {full_slot_str}")
        
        # 5. Return result
        return {
            "booking_id": new_booking["booking_id"],
            "slot": full_slot_str,
            "type": service_note
        }

# ==========================================
# ü§ñ AGENT NODE (Updated Logic)
# ==========================================
def scheduling_node(state: AgentState) -> AgentState:
    print("üóìÔ∏è [Scheduler] Analyzing priority for booking...")
    
    # Get Priority from the upstream Agent (Diagnosis Agent)
    # Default is "Medium" if not found
    priority = state.get("priority_level", "Medium")
    
    # ---------------------------------------------------------
    # üß† INTELLIGENT SCHEDULING LOGIC
    # ---------------------------------------------------------
    should_book = False

    if priority == "Critical":
        # Case 1: Critical Issue -> AUTO BOOK (No user permission needed)
        print("üö® [Scheduler] Critical issue detected. Auto-authorizing booking.")
        should_book = True
        
    elif state.get("customer_decision") == "BOOKED":
        # Case 2: Non-Critical but User said "Yes" in Customer Engagement
        print(f"üë§ [Scheduler] Customer explicitly authorized booking for {priority} priority.")
        should_book = True
        
    else:
        # Case 3: Non-Critical and No User Confirmation -> SKIP
        print(f"‚è∏Ô∏è [Scheduler] Priority is '{priority}' and no customer confirmation. Skipping booking.")
        return state

    # ---------------------------------------------------------
    # ‚ö° EXECUTE BOOKING (Only if should_book is True)
    # ---------------------------------------------------------
    if should_book:
        agent_name = "SchedulingAgent"
        v_id = state.get("vehicle_id", "Unknown-ID")

        try:
            # Securely call the booking service
            booking_result = secure_call(
                agent_name,
                "SchedulerService",
                SchedulerService.book_slot,
                v_id,
                priority
            )
            
            # EXTRACT DATA AND UPDATE STATE
            state["booking_id"] = booking_result["booking_id"]
            state["selected_slot"] = booking_result["slot"]
            
            print(f"‚úÖ [Scheduler] CONFIRMED! Date: {booking_result['slot']} (ID: {booking_result['booking_id']})")
            
        except PermissionError as e:
            state["error_message"] = str(e)
            print(f"‚õî [UEBA] BLOCKED: {e}")

    return state